#!/USSR/bin/env bash

#-- Header logging ---------------------------------------------------------------------------------
HEADER_COLOR="92"
LAST_HEADER_COLOR="93"

SUBHEADER_COLOR="95"
LAST_SUBHEADER_COLOR="96"

function u_toggle_header_color() {
    if [[ "$1" == "header" ]]; then
        TMP_HEADER_COLOR=$HEADER_COLOR
        HEADER_COLOR=$LAST_HEADER_COLOR
        LAST_HEADER_COLOR=$TMP_HEADER_COLOR
    else
        TMP_HEADER_COLOR=$SUBHEADER_COLOR
        SUBHEADER_COLOR=$LAST_SUBHEADER_COLOR
        LAST_SUBHEADER_COLOR=$TMP_HEADER_COLOR
    fi
}

function u_header() {
    u_toggle_header_color "header"

    IN_HEADER=1
    HEADER_TITLE="$1"
}
function u_exit_header() {
    unset IN_HEADER
}

function u_subheader() {
    u_toggle_header_color "subheader"

    IN_SUBHEADER=1
    SUBHEADER_TITLE="$1"
}
function u_exit_subheader() {
    unset IN_SUBHEADER
}

function u_print_header() {
    if [[ $IS_HEADLESS ]]; then
        [[ $IN_SUBHEADER ]] && printf "     " && HEADLESS_LENGTH=${#SUBHEADER_TITLE}
        [[ ! $IN_HEADER && $IN_HEADER ]] && printf "   " && HEADLESS_LENGTH=${#HEADER_TITLE}

        for (( c=0; c<$HEADLESS_LENGTH; c++ )); do
            printf " "
        done

        unset IS_HEADLESS

        return
    fi

    if [[ $IN_SUBHEADER ]]; then
        printf "  [\e[1;${SUBHEADER_COLOR}m$SUBHEADER_TITLE\e[0m] "
        return
    fi

    if [[ $IN_HEADER ]]; then
        printf "[\e[1;${HEADER_COLOR}m$HEADER_TITLE\e[0m] "
    fi
}

#-- Message logging --------------------------------------------------------------------------------
function u_print() {
    u_print_header
    printf "$@"
}
function u_printl() {
    u_print "$@"
    printf "\n"
}

function u_headless() {
    IS_HEADLESS=1

    u_print "$@"
}
function u_headlessl() {
    u_headless "$@"
    printf "\n"
}

function u_error() {
    u_printl "[\e[1;91mError\e[0m] %s" "$@"
}
function u_warning() {
    u_printl "[\e[1;93mWarning\e[0m] %s" "$@"
}

function new_line() {
    printf "\n"
}

#-- Success logging --------------------------------------------------------------------------------
function u_pass() {
    printf "\e[92mOK\e[0m\n"
}
function u_fail() {
    printf "\e[91mERROR\e[0m\n"
}
function u_skip() {
    printf "\e[93mSKIPPED\e[0m\n"
}

function check_success() {
    if [[ "$?" == "0" ]]; then
        u_pass
        return
    fi

    u_fail
    exit 1
}

#-- Confirmation -----------------------------------------------------------------------------------
function seek_confirmation() {
    CONFIRM_MESSAGE="[y/N]"

    if [ -n "$1" ]; then
        CONFIRM_MESSAGE="$1 $CONFIRM_MESSAGE"
    fi

    u_print_header
    read -p "$CONFIRM_MESSAGE: " -n 1
    printf "\r\e[K"
}
function is_confirmed() {
    if [[ "$REPLY" =~ ^[yY]$ ]]; then
        unset REPLY
        return 0
    fi

    unset REPLY
    return 1
}
function set_confirmed() {
    REPLY='y'
}

#-- Selection --------------------------------------------------------------------------------------
function print_selection() {
    SELECTED_ID="$1"
    shift

    # Update List
    LIST_ID="1"
    for i in "$@"; do
        if [[ "$LIST_ID" == "1" && ! $FIRST_SELECTION_RUN ]]; then
            printf "\e[$#A"
        fi

        if [[ "$LIST_ID" == "$SELECTED_ID" ]]; then
            printf "\e[96m"
        fi

        u_headlessl "%s $i\e[0m" "â€¢"

        LIST_ID="$(($LIST_ID+1))"
    done

    if [[ -n $FIRST_SELECTION_RUN ]]; then
        unset FIRST_SELECTION_RUN
    fi
}
function delete_selection() {
    printf "\e[$1A"

    for (( c=1; c<=$1; c++ )); do
        printf "\r\e[K\n"
    done

    printf "\e[$1A"
}
function u_selection() {
    CURRENT_SELECTION="1"
    FIRST_SELECTION_RUN=1
    SELECTION_LENGTH="$#"

    # Print title if exists
    if [[ "${1:0:1}" == '^' ]]; then
        u_printl "${1:1}"
        shift
    fi

    # Check for a default parameter
    if [[ "${1:0:1}" == '#' ]]; then
        CURRENT_SELECTION="${1:1}"
        SELECTION_LENGTH="$((SELECTION_LENGTH-1))"
        shift
    fi

    print_selection $CURRENT_SELECTION $@

    # Selection
    while read -rsn1 key; do
        case "$key" in
            $'\x1b')
                read -rsn1 -t 0.1 tmp
                if [[ "$tmp" == '[' ]]; then
                    read -rsn1 -t 0.1 tmp
                    case "$tmp" in
                        "A")
                            if [[ "$CURRENT_SELECTION" == "1" ]]; then
                                CURRENT_SELECTION="$SELECTION_LENGTH"
                            else
                                CURRENT_SELECTION="$(($CURRENT_SELECTION-1))"
                            fi
                            ;;
                        "B")
                            if [[ "$CURRENT_SELECTION" == "$SELECTION_LENGTH" ]]; then
                                CURRENT_SELECTION="1"
                            else
                                CURRENT_SELECTION="$(($CURRENT_SELECTION+1))"
                            fi
                            ;;
                    esac
                fi
                ;;
            "")
                break;
                ;;
        esac
        print_selection $CURRENT_SELECTION $@
    done
    delete_selection $SELECTION_LENGTH
    SELECTION_VALUE="${!CURRENT_SELECTION}"
}
function is_selection() {
    if [[ "$1" == "$SELECTION_VALUE" ]]; then
        return 0
    fi

    return 1
}
function set_selection() {
    SELECTION_VALUE="$1"
}

#-- Cursor manipulation ----------------------------------------------------------------------------
# From http://askubuntu.com/questions/366103/saving-more-corsor-positions-with-tput-in-bash-terminal
function save_cursor() {
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" > /dev/tty
    IFS=';' read -r -d R -a pos
    stty $oldstty
    eval "$1[0]=$((${pos[0]:2} - 1))"
    eval "$1[1]=$((${pos[1]} - 1))"
}
function restore_cursor() {
    eval ARRAY=\( \${${1}[@]} \)
    tput cup ${ARRAY[0]} ${ARRAY[1]}
}
function place_in() {
    save_cursor tmp_place
    restore_cursor $1
    shift
    u_printl "$@"
    restore_cursor tmp_place
}

#-- Package Install --------------------------------------------------------------------------------
function package_install() {
    u_print "Installing $1..."

    if package_installed $1; then
        u_skip
        return
    fi

    sudo dnf install $1 -qy >>$DOTFILES_LOG_FILE 2>&1 || {
        u_fail
        exit 1
    }

    u_pass
}
function package_groupinstall() {
    u_print "Installing $1..."

    sudo dnf groupinstall "$1" -qy >>$DOTFILES_LOG_FILE 2>&1 || {
        u_fail
        exit 1
    }

    u_pass
}
function package_installed() {
    rpm -qa | grep $1 >/dev/null 2>&1 || {
        if cmd_exists $1; then
            return 0
        fi

        return 1
    }

    return 0
}
function install_build_tools() {
    package_groupinstall "Development Tools"
    package_groupinstall "C Development Tools and Libraries"

    package_install "autoconf"
    package_install "automake"
    package_install "libtool"
    package_install "intltool"
    package_install "gettext"
    package_install "gettext-devel"
}

#-- Silent commands --------------------------------------------------------------------------------
function log_output() {
    "$@" >>$DOTFILES_LOG_FILE 2>&1
}
function silent_output() {
    "$@" >/dev/null 2>&1
}

#-- Command existance ------------------------------------------------------------------------------
function cmd_exists() {

    command -v $1 >/dev/null 2>&1 && {
        return 0
    }

    return 1
}
