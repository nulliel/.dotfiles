#!/usr/bin/env bash

#-- Properties -------------------------------------------------------------------------------------
declare -i _header_color="92"        # Main header color
declare -i _header_color_alt="93"    # Alternate header color

declare -i _subheader_color="95"        # Main subheader color
declare -i _subheader_color_alt="96"    # Alternate header color

declare _headless=false    # Flag to ignore header printing

declare _header_value=false       # Header title
declare _subheader_value=false    # Subheader title

#-- Color ------------------------------------------------------------------------------------------
_toggle_header () {
  read -r _header_color _header_color_alt<<<"$_header_color_alt $_header_color"
}
_toggle_subheader () {
  read -r _subheader_color _subheader_color_alt<<<"$_subheader_color_alt $_subheader_color"
}

header () {
  _toggle_header

  _header_value="$1"
}
exit_header () {
  _header_value=false
}

subheader () {
  _toggle_subheader

  _subheader_value="$1"
}
exit_subheader () {
  _subheader_value=false
}

#-- Messaging --------------------------------------------------------------------------------------
_print_header () {
  local headless_length=0

  if [[ "$_headless" = true ]]; then
    if [[ "$_subheader_value" != false ]]; then
      headless_length=$(( ${#_subheader_value} + 5 ))
    elif [[ "$_header_value" != false ]]; then
      headless_length=$(( ${#_header_value} + 3 ))
    fi

    for (( i=0; i<"$headless_length"; i++ )); do
      printf " "
    done

    _headless=false
    return
  fi

  if [[ "$_subheader_value" != false ]]; then
    printf "  [\033[1;%bm%b\033[0m] " "$_subheader_color" "$_subheader_value"
  elif [[ "$_header_value" != false ]]; then
    printf "[\033[1;%bm%b\033[0m] " "$_header_color" "$_header_value"
  fi
}

#-- Print to console -------------------------------------------------------------------------------
console () {
  _print_header
  printf "%b" "$@"
}

consolel () {
  console "$*\n"
}

consoleh () {
  _headless=true
  console "$*"
}

consolehl () {
  consoleh "$*\n"
}

#-- Print to log -----------------------------------------------------------------------------------
log () {
  _print_header 1>&3 2>&4
  printf "%b" "$@" 1>&3 2>&4
}

logl () {
  log "$*\n"
}

logh () {
  _headless=true
  log "$*"
}

loghl () {
  logh "$*\n"
}

#-- Print to both console and log ------------------------------------------------------------------
clog () {
  _print_header 1>&5 2>&6
  printf "%b" "$@" 1>&5 2>&6
}

clogl () {
  log "$*\n"
}

clogh () {
  _headless=true
  log "$*"
}

cloghl () {
  logh "$*\n"
}

#-- Error logging ----------------------------------------------------------------------------------
error () {
  clogl "[\033[1;91mError\033[0m] $*"
}

warning () {
  clogl "[\0ee[1;93mWarning\033[0m] $*"
}

fatal () {
  clogl "[\033[1;91mFatal\033[0m] $*\n"
  fatal_message 1>&5 2>&6

  if [[ "$#" -eq 2 && "$2" =~ ^[0-9]+$ ]]; then
    exit "$2"
  else
    exit 1
  fi
}

fatal_message () {
  printf "\n[\e[1;91mError\e[0m] Check the logfile at %s for more information.\n" "$DOTFILES_LOG"
}

#-- Utility logging --------------------------------------------------------------------------------
pass () {
  clogl "\033[1;92mOK\033[0m"
  logl ""
  sleep "0.01"
}

fail () {
  clogl "\033[1;91mERROR\033[0m"
  logl ""
  sleep "0.01"
}

skip () {
  if [[ "$#" -eq 1 ]]; then
    clog "$1"
    sleep "0.01"
  fi

  clogl "\033[1;93mSKIPPED\033[0m"
  logl ""
  sleep "0.01"
}

new_line () {
  consolel ""
}

clear_line () {
  console "\r\033[K"
}

clear_rest_of_line () {
  console "\033[K"
}

check_success () {
  "$@" || {
    fail
    fatal_message
    exit 1
  }

  pass
}

#-- Progress ---------------------------------------------------------------------------------------
_print_progress () {
  clog "\n"

  while read -r data; do
    progress_list=("${progress_list[@]:1}")           # Pop the first object off the list
    progress_list[5]=$(echo "$data" | tr -d '\n' )    # Move the new data to the end of the list

    loghl "${progress_list[5]}"

    if [[ "$progress_init" = false ]]; then
      console "\033[${#progress_list[@]}A"
    fi

    for item in "${progress_list[@]}"; do
      if [[ "$item" = "+" ]]; then
        item=""
      fi

      clear_line
      consolehl "| $item"
    done

    progress_init=false
  done
}

_clear_progress () {
  console "${#progress_list[@]}"

  if [[ "$1" -eq 0 ]]; then
    console "\r\033[K\033[A"
  fi

  for item in "${progress_list[@]}"; do
    console "\r\033[K\033[A"
  done

  console "\r\033[K"
}

show_progress () {
  local progress_init=true         # Suppress initial render
  local progress_list=(+ + + + +)  # Initial progress list
  local set_return=0
  local pacman=1

  # Don't show progress on a small console
  if [[ "$((SCRIPT_HEIGHT))" -le "8" ]]; then
    "$@" && return 0 || return "$!"
  fi

  log "\n"

  save_cursor progress_cursor

  # Pad the bottom of the console by 6 lines
  if [[ "${progress_cursor[0]}" -ge "$((SCRIPT_HEIGHT-6))" ]]; then
    local lines_under="$((SCRIPT_HEIGHT - progress_cursor[0]))"

    for (( i=0; i<"$lines_under"; i++ )); do
      console "\n"
    done

    for (( i=0; i<"$((6 - lines_under))"; i++ )); do
      progress_cursor[0]="$((progress_cursor[0] - 1))"
      console "\n"
    done

    progress_cursor[0]="$((progress_cursor[0] - 1))"
    restore_cursor progress_cursor
  fi

  { consolel ""; "$@"; } | _print_progress

  if [[ "${PIPESTATUS[0]}" != "0" ]]; then
    set_return=1
  fi

  if [[ "$*" == *"pacman"* ]]; then
    pacman=0
  fi

  _clear_progress "$pacman"
  restore_cursor progress_cursor
  clear_rest_of_line

  return "$set_return"
}
